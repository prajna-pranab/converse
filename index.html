<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Security-Policy" content="script-src 'unsafe-inline'" />
    <title>Converse with your Conversol!</title>
	<link rel="shortcut icon" type="image/png" href="/assets/icons/png/Icon-256.png" />
	<link rel="apple-touch-icon" href="/assets/icons/png/Icon-256.png" />
    <script defer>
    	/*
    		Get info from solar charge controllers that use Voltronics' protocol.
    		Should work with Voltronic, Conversol, Axpert and other controllors
    		that use WatchPower for monitoring and management. It might even
    		work somewhat with Voltronics UPS, which uses a similar protocol.

    		by Prajna Pranab, Libra 13520

    		NOTES:
    		CV = Constant Voltage = Absorb
    		CC = Constant Current = bulk
    		Calibrate battery voltage reading:
    		See: http://forums.aeva.asn.au/viewtopic.php?f=64&t=4332&start=2275#p71631
    		BTAg01XP nudge up
    		BTA</9d* nudge down

    		Conversol 5KW III, Axpert VM III, PIP5048GK
    	*/
		const sp = require('serialport'),
			Readline = require('@serialport/parser-readline'),
			parser = new Readline({ delimiter: '\r' });
        let test = false,	// set true or disconnect serial cable to run in test mode
    		port,			// reference for opened coms port
        	cmd;			// last command that was sent
 
		// parse data received from the controller
		const parseQuery = (cmd, data) => {
			const queries = {
				QPI: () => {
					// (PI00
					if (data == '(NAK') return '<b>QPI (Protocol ID)</b><br />Not recognised'
					return '<b>QPI (Protocol ID)</b><br />' +
						'Protocol ID: ' + data.slice(1);
				},
				QID: () => {
					// (00000000000000
					if (data == '(NAK') return '<b>QID (Serial Number)</b><br />Not recognised'
					return '<b>QID (Serial number)</b><br />' +
						'Serial No: ' + data.slice(1);
				},
				QVFW: () => {
					// (VERFW:00000.00
					if (data == '(NAK') return '<b>QVFW (Main CPU FW version)</b><br />Not recognised'
					const fields = data.split(/\.|\:/);
					return '<b>QVFW (Main CPU Firmware version)</b><br />' +
						'Version: ' + parseInt(fields[1]) + '.' + fields[2];
				},
				QVFW2: () => {
					// (VERFW2:00000.00
					if (data == '(NAK') return '<b>QVFW2 (SCC1 CPU Firmware version)</b><br />Not recognised'
					const fields = data.split(/\.|\:/);
					return '<b>QVFW2 (SCC1 CPU Firmware version)</b><br />' +
						'Version: ' + parseInt(fields[1]) + '.' + fields[2];
				},
				QVFW3: () => {
					// (VERFW3:00000.00
					if (data == '(NAK') return '<b>QVFW3 (SCC2 CPU Firmware version)</b><br />Not recognised'
					const fields = data.split(/\.|\:/);
					return '<b>QVFW3 (SCC2 CPU Firmware version)</b><br />' +
						'Version: ' + parseInt(fields[1]) + '.' + fields[2];
				},
				QVFW4: () => {
					// (VERFW4:00000.00
					if (data == '(NAK') return '<b>QVFW4 (SCC3 CPU Firmware version)</b><br />Not recognised'
					const fields = data.split(/\.|\:/);
					return '<b>QVFW4 (SCC3 CPU Firmware version)</b><br />' +
						'Version: ' + parseInt(fields[1]) + '.' + fields[2];
				},
				QPIRI: () => {
					// (000.0 00.0 000.0 00.0 00.0 0000 0000 00.0
					//	00.0 00.0 00.0 00.0 0 00 000 0 0 0 0 10 0 0 00.0 0 0
					// our inverter doesn't send last field!
					if (data == '(NAK') return '<b>QPIRI (Rating Information)</b><br />Not recognised'
					const batteryTypes = {'0': 'AGM', '1': 'FLA', '2': 'User Defined'},
						voltageRanges = {'0': 'Appliance', '1': 'UPS'},
						outputSources = {'0': 'Utility first', '1': 'Solar first', '2': 'SBU'},
						chargerSources = {'0': 'Utility first', '1': 'Solar first',
							'2': 'Solar + Utility', '3': 'Solar only'},
						deviceTypes = {'00': 'Grid tie', '01': 'Off grid', '10': 'Hybrid',
							'11': 'Off Grid, 2 trackers', '20': 'Off grid, 3 trackers'},
						topologies = {'0': 'transformerless', '1': 'transformer'}
						outputModes = {'0': 'Single', '1': 'Parallel', '2': 'Phase 1',
							'3': 'Phase 2', '4': 'Phase 3'},
						pvStatuses = {'0': 'On one OK', '1': 'On all OK'},
						balances = {'0': 'PV max current', '1': 'PV max power'},
						fields = data.slice(1).split(' ');
					return '<b>QPIRI (Rating Information)</b><br />' +
						'Grid rating voltage: ' + parseFloat(fields[0]) + 'V<br />' +
						'Grid rating current: ' + parseFloat(fields[1]) + 'A<br />' +
						'AC output rating voltage: ' + parseFloat(fields[2]) + 'V<br />' +
						'AC output rating frequency: ' + parseFloat(fields[3]) + 'Hz<br />' +
						'AC output rating current: ' + parseFloat(fields[4]) + 'A<br />' +
						'AC output rating apparent power: ' + parseInt(fields[5]) + 'VA<br />' +
						'AC output rating active power: ' + parseInt(fields[6]) + 'W<br />' +
						'Battery rating voltage: ' + parseFloat(fields[7]) + 'V<br />' +
						'Back-to-grid voltage: ' + parseFloat(fields[8]) + 'V<br />' +
						'Low voltage disconnect: ' + parseFloat(fields[9]) + 'V<br />' +
						'Bulk charge voltage: ' + parseFloat(fields[10]) + 'V<br />' +
						'Float voltage: ' + parseFloat(fields[11]) + 'V<br />' +
						'Battery Type: ' + batteryTypes[fields[12]] + '<br />' +
						'Max AC charging current: ' + parseInt(fields[13]) + 'A<br />' +
						'Max DC charging current: ' + parseInt(fields[14]) + 'A<br />' +
						'AC Input voltage range: ' + voltageRanges[fields[15]] + '<br />' +
						'Output source priority: ' + outputSources[fields[16]] + '<br />' +
						'Charger source priority: ' + chargerSources[fields[17]] + '<br />' +
						'Max in parallel: ' + parseInt(fields[18]) + '<br />' +
						'Device type: ' + deviceTypes[fields[19]] + '<br />' +
						'Topology: ' + topologies[fields[20]] + '<br />' +
						'Output mode: ' + outputModes[fields[21]] + '<br />' +
						'Battery re-discharge voltage: ' + parseFloat(fields[22]) + 'V<br />' +
						'PV condition for parallel: ' + pvStatuses[fields[23]] + '<br />' +
						'PV power balance: ' + balances[fields[24]];
				},
				QFLAG: () => {
					// (EaxyzDbjkuv
					if (data == '(NAK') return '<b>QFLAG (Flag status)</b><br />Not recognised'
					const flag = letter => {
						if (data.indexOf(letter) == -1) return 'Not supported<br />';
						return (data.indexOf(letter) < data.indexOf('D') ?
							'Enabled<br />' : 'Disabled<br />');
					}
					return '<b>QFLAG (Flag status)</b><br />' + 
						'Buzzer: ' + flag('a') +
						'Overload bypass ' + flag('b') +
						'Power saving: ' + flag('j') +
						'LCD timeout: ' + flag('k') +
						'Overload restart: ' + flag('u') +
						'Over temp restart: ' + flag('v') +
						'Backlight: ' + flag('x') +
						'Source interrupt alarm: ' + flag('y') +
						'Record fault codes: ' + flag('z') +
						'Data log popup: ' + flag('l');
				},
				QPIGS: () => {
					// (000.0 00.0 000.0 00.0 0000 0000 000 000 00.00 000 
					//	000 0000 0000 000.0 00.00 00000 10101010 00 00 00000 000
					if (data == '(NAK') return '<b>QPIGS (Inverter status)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[16];
					return '<b>QPIGS (Inverter status)</b><br />' + 
						'Grid voltage: ' + parseFloat(fields[0]) + 'V<br />' +
						'Grid frequency: ' + parseFloat(fields[1]) + 'Hz<br />' +
						'AC output voltage: ' + parseFloat(fields[2]) + 'V<br />' +
						'AC output frequency: ' + parseFloat(fields[3]) + 'Hz<br />' +
						'AC output apparent power: ' + parseInt(fields[4]) + 'VA<br />' +
						'AC output active power: ' + parseInt(fields[5]) + 'W<br />' +
						'Output load: ' + parseInt(fields[6]) + '%<br />' +
						'Bus voltage: ' + parseFloat(fields[7]) + 'V<br />' +
						'Battery voltage: ' + parseFloat(fields[8]) + 'V<br />' +
						'Battery charging current: ' + parseInt(fields[9]) + 'A<br />' +
						'Battery capacity: ' + parseInt(fields[10]) + '%<br />' +
						'Heatsink temp: ' + parseInt(fields[11]) + '&deg;C<br />' +
						'SCC1 Input current: ' + parseFloat(fields[12]) + 'A<br />' +
						'SCC1 Input voltage: ' + parseFloat(fields[13]) + 'V<br />' +
						'SCC1 Battery voltage: ' + parseFloat(fields[14]) + 'V<br />' +
						'Battery discharge current: ' + parseInt(fields[15]) + 'A<br />' +
						'Status: <br />&nbsp;&nbsp;' + 
						'Add SBU priority: ' + (flags[0] == '1' ? 'Yes' : 'No') +
							'<br />&nbsp;&nbsp;' +
						'Config changed: ' + (flags[1] == '1' ? 'Yes' : 'No') +
							'<br />&nbsp;&nbsp;' +
						'SCC Firmware updated: ' + (flags[2] == '1' ? 'Yes' : 'No') +
							'<br />&nbsp;&nbsp;' +
						'Load status: ' + (flags[3] == '1' ? 'On' : 'Off') +
							'<br />&nbsp;&nbsp;' +
						'Steady voltage: ' + (flags[4] == '1' ? 'Yes' : 'No') +
							'<br />&nbsp;&nbsp;' +
						'Charging status: ' + (flags[5] == '1' ? 'On' : 'Off') +
							'<br />&nbsp;&nbsp;' +
						'SCC1 charging: ' + (flags[6] == '1' ? 'On' : 'Off') +
							'<br />&nbsp;&nbsp;' +
						'AC charging: ' + (flags[7] == '1' ? 'On' : 'Off') +
							'<br />' +
						'Battery voltage offset: ' +
							parseInt(fields[17]) +'mV<br />' +
						'EEprom version: ' +
							fields[18] + '<br />' +
						'PV1 Charging power: ' +
							parseInt(fields[19]) + 'W';
				},
				// QPGS0
				QPIGS2: () => {
					// (0000 000.0 00.00 00000 00000000 0000 0000 0000 
					//	000.0 00.00 0000 00000
					if (data == '(NAK') return '<b>QPIGS2 (Inverter status 2)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[4];
					return '<b>QPIGS2 (Inverter status 2)</b><br />' +
						'SCC2 input current: ' + parseInt(fields[0]) + 'A<br />' +
						'SCC2 input voltage: ' + parseFloat(fields[1]) + 'V<br />' +
						'SCC2 battery voltage: ' + parseFloat(fields[2]) + 'V<br />' +
						'SCC2 charging power: ' + parseInt(fields[3]) + 'W<br />' +
						'SCC2 charging: ' +
							(flags[0] == '1' ? 'Yes<br />' : 'No<br />') +
						'SCC3 charging: ' +
							(flags[1] == '1' ? 'Yes<br />' : 'No<br />') +
						'AC charging current: ' + parseInt(fields[5]) + 'A<br />' +
						'AC charging power: ' + parseInt(fields[6]) + 'W<br />' +
						'SCC3 input current: ' + parseInt(fields[7]) + 'A<br />' +
						'SCC3 input voltage: ' + parseFloat(fields[8]) + 'V<br />' +
						'SCC3 battery voltage: ' + parseFloat(fields[9]) + 'V<br />' +
						'SCC3 charging power: ' + parseInt(fields[10]) + 'W<br />' +
						'Total PV charging power: ' + parseInt(fields[11]) + 'W';
				},
				QMOD: () => {
					if (data == '(NAK') return '<b>QMOD (Operating Mode)</b><br />Not recognised'
					const modes = {'P': 'Power On', 'S': 'Standby', 'L': 'Line',
						'B': 'Battery', 'Fault': 'Fault', 'H': 'Power Saving'};
					// (B
					return '<b>QMOD (Operating Mode)</b><br />' + 
						'Mode: ' + modes[data[1]];
				},
				QPIWS: () => {
					/*
						Returns different values on protocol 3000
					*/
					// (10101010101010101010101010101010101010
					if (data == '(NAK') return '<b>QPIWS (Warning Status)</b><br />Not recognised'
					const isSet = pos => { return data[pos] == '1' }
					const chk = (str, pos, type) => {
						switch (type) {
							case 'none': return '<span class="noFault">' + str + '</span><br />';
							case 'warn': return (isSet(pos) ?
								'<span class="warning">' + str + '</span><br />' :
								'<span class="noFault">' + str + '</span><br />');
							case 'fault': return (isSet(pos) ?
								'<span class="fault">' + str + '</span><br />' :
								'<span class="noFault">' + str + '</span><br />');
							case 'check': return (isSet(pos) && isSet(2) ?
								'<span class="fault">' + str + '</span><br />' :
								isSet(pos) ? '<span class="warning">' + str + '</span><br />' :
								'<span class="noFault">' + str + '</span><br />');
						}
					}
					return '<b>QPIWS (Warning Status)</b><br />' +
						chk('Reserved', 1, 'none') +
						chk('Inverter fault', 2, 'fault') +
						chk('Bus over voltage', 3, 'fault') +
						chk('Bus under voltage', 4, 'fault') +
						chk('Bus soft fail', 5, 'fault') +
						chk('Line fail', 6, 'warn') +
						chk('OPV short', 7, 'warn') +
						chk('Inverter voltage too low', 8, 'fault') +
						chk('Inverter voltage too high', 9, 'fault') +
						chk('Over temperature', 10, 'check') +
						chk('Fan locked', 11, 'check') +
						chk('High battery voltage', 12, 'check') +
						chk('Low battery', 13, 'warn') +
						chk('Overcharge', 14, 'warn') +
						chk('Battery under shutdown', 15, 'warn') +
						chk('Battery derating', 16, 'warn') +
						chk('Overload', 17, 'check') +
						chk('Eeprom fault', 18, 'warn') +
						chk('Inverter over current', 19, 'fault') +
						chk('Inverter soft fail', 20, 'fault') +
						chk('Self test fail', 21, 'fault') +
						chk('OP DC voltage over', 22, 'fault') +
						chk('Battery disconnected', 23, 'fault') +
						chk('Current sensor fail', 24, 'fault') +
						chk('Battery short', 25, 'fault') +
						chk('Power limit', 26, 'warn') +
						chk('SCC1 High PV voltage', 27, 'warn') +
						chk('SCC1 MPPT overload fault', 28, 'warn') +
						chk('SCC1 MPPT overload warning', 29, 'warn') +
						chk('SCC1 Battery too low to charge', 30, 'warn') +
						chk('SCC2 High PV voltage', 31, 'warn') +
						chk('SCC2 MPPT overload fault', 32, 'warn') +
						chk('SCC2 MPPT overload warning', 33, 'warn') +
						chk('SCC2 Battery too low to charge', 34, 'warn') +
						chk('SCC3 High PV voltage', 35, 'warn') +
						chk('SCC3 MPPT overload fault', 36, 'warn') +
						chk('SCC3 MPPT overload warning', 37, 'warn') +
						chk('SCC3 Battery too low to charge', 38, 'warn');
				},
				QDI: () => {
					if (data == '(NAK') return '<b>QDI (Default setting values)</b><br />Not recognised'
					const modes = {'0': 'Solo', '1': 'Parallel', '2': 'Phase 1',
						'3': 'Phase 2', '4': 'Phase 2'},
						pvStatuses = {'0': 'On one OK', '1': 'On all OK'},
						balances = {'0': 'PV max current', '1': 'PV max power'},
						stages = {'0': 'Auto', '1': '2 stage', '2': '3 stage'};
					// (000.0 00.0 0000 00.0 00.0 00.0 00.0 00 0 0 
					//	0 0 0 0 0 0 1 1 0 0 1 0 00.0 0 0 1 1 000 000
					const fields = data.slice(1).split(' ');
					return '<b>QDI (Default setting values)</b><br />' +
						'AC output voltage: ' + parseFloat(fields[0]) + 'V<br />' +
						'AC output frequency: ' + parseFloat(fields[1]) + 'Hz<br />' +
						'Max AC charging current: ' + parseInt(fields[2]) + 'A<br />' +
						'Low voltage disconnect: ' + parseFloat(fields[3]) + 'V<br />' +
						'Float voltage: ' + parseFloat(fields[4]) + 'V<br />' +
						'Bulk voltage: ' + parseFloat(fields[5]) + 'V<br />' +
						'Back-to-grid voltage: ' + parseFloat(fields[6]) + 'V<br />' +
						'Max DC charging current: ' + parseInt(fields[7]) + 'A<br />' +
						'AC Input voltage range: ' +
							(fields[8] == '0' ? 'Appliance<br />' : 'UPS<br />') +
						'Output source priority: ' +
							(fields[9] == '0' ? 'Utility first<br />' : 'Solar first<br />') +
						'Charger source priority: ' +
							(fields[10] == '0' ? 'Utility first<br />' : 'Solar first<br />') +
						'Battery type: ' +
							(fields[11] == '0' ? 'AGM<br />' : 'FLA<br />') +
						'Buzzer: ' +
							(fields[12] == '0' ? 'Enabled<br />' : 'Disabled<br />') +
						'Power saving: ' +
							(fields[13] == '0' ? 'Disabled<br />' : 'Enabled<br />') +
						'Overload restart: ' +
							(fields[14] == '0' ? 'Disabled<br />' : 'Enabled<br />') +
						'Over temp restart: ' +
							(fields[15] == '0' ? 'Disabled<br />' : 'Enabled<br />') +
						'LCD backlight: ' +
							(fields[16] == '0' ? 'Disabled<br />' : 'Enabled<br />') +
						'Primary source interrupt alarm: ' +
							(fields[17] == '0' ? 'Disabled<br />' : 'Enabled<br />') +
						'Fault code record: ' +
							(fields[18] == '0' ? 'Disabled<br />' : 'Enabled<br />') +
						'Overload bypass: ' +
							(fields[19] == '0' ? 'Disabled<br />' : 'Enabled<br />') +
						'LCD timeout: ' +
							(fields[20] == '0' ? 'Disabled<br />' : 'Enabled<br />') +
						'Output mode: ' + modes[fields[21]] + '<br />' +
						'Battery re-discharge voltage: ' + parseFloat(fields[22]) + 'V<br />' +
						'PV condition for parallel: ' + pvStatuses[fields[23]] + '<br />' +
						'PV power balance: ' + balances[fields[24]] + '<br />' +
						'Charging stages: ' + stages[fields[25]] + '<br />' +
						'Data log popup: ' +
							(fields[26] == '0' ? 'Disabled<br />' : 'Enabled<br />') +
						'Max Solar charging current: ' + parseInt(fields[27]) + 'A<br />' +
						'CV Charging time: ' + parseInt(fields[28]) + 'mins';
				},
				QBEQI: () => {
					// (1 000 000 000 000 00.00 000 000
					if (data == '(NAK') return '<b>QBEQI (Equalisation status)</b><br />Not recognised'
					const fields = data.slice(1).split(' ');
					return '<b>QBEQI (Equalisation status)</b><br />' +
						'Battery equalized: ' + (fields[0] == '1' ? 'Yes' : 'No') + '<br />' +
						'Equalize time: ' + parseInt(fields[1]) + 'mins<br />' +
						'Equalize Interval: ' + parseInt(fields[2]) + 'days<br />' +
						'Max current: ' + parseInt(fields[3]) + 'A<br />' +
						'Next equalize: ' + parseInt(fields[4]) + 'days<br />' +
						'Equalized voltage: ' + parseFloat(fields[5]) + 'V<br />' +
						'Absorb time: ' + parseInt(fields[6]) + 'mins<br />' +
						'Equalize timeout: ' + parseInt(fields[7]) + 'mins';
				},
				QMCHGCR: () => {
					// (000 000 000 000
					if (data == '(NAK') return '<b>QMCHGCR (Max charging current settings)</b><br />Not recognised'
					const fields = data.slice(1).split(' ');
					let details = '<b>QMCHGCR (Max charging current settings)</b><br />';
					for (let fld of fields)
						details += parseInt(fld) + 'A<br />';
					return details;
				},
				QMUCHGCR: () => {
					// (000 000 000 000 000 000
					if (data == '(NAK') return '<b>QMUCHGCR (Max utility charging current settings)</b><br />Not recognised'
					const fields = data.slice(1).split(' ');
					let details = '<b>QMUCHGCR (Max utility charging current settings)</b><br />';
					for (let fld of fields)
						details += parseInt(fld) + 'A<br />';
					return details;
				},
				QMSCHGCR: () => {
					// (000 000 000 000 000 000
					if (data == '(NAK') return '<b>QMSCHGCR (Max solar charging current settings)</b><br />Not recognised'
					const fields = data.slice(1).split(' ');
					let details = '<b>QMUCHGCR (Max solar charging current settings)</b><br />';
					for (let fld of fields)
						details += parseInt(fld) + 'A<br />';
					return details;
				},
				QBOOT: () => {
					// (1
					if (data == '(NAK') return '<b>QBOOT (DSP has bootstrap?)</b><br />Not recognised'
					return '<b>QBOOT (DSP has bootstrap?)</b><br />' +
						'Has bootstrap: ' + (data.slice(1) == '1' ? 'Yes' : 'No');
				},
				QOPM: () => {
					// (00
					if (data == '(NAK') return '<b>QOPM (Output mode)</b><br />Not recognised'
					const modes = {'00': 'Solo', '01': 'Parallel', '02': 'Phase 1',
						'03': 'Phase 2', '04': 'Phase 3'};
					return '<b>QOPM (Output mode)</b><br />' +
						'Mode: ' + modes[data.slice(1)];
				},
				QCST: () => {
					// (00
					if (data == '(NAK') return '<b>QCST (Charging stage enquiry)</b><br />Not recognised'
					const modes = {'00': 'Auto', '01': '2 Stage', '02': '3 Stage'};
					return '<b>QCST (Charging stage enquiry)</b><br />' +
						'Stages: ' + modes[data.slice(1)];
				},
				QCVT: () => {
					// (000
					if (data == '(NAK') return '<b>QCVT (Charging time in CV mode)</b><br />Not recognised'
					const details = data.slice(1);
					return '<b>QCVT (Charging time in CV mode)</b><br />' +
						'Time: ' + (details == '255' ? 'Auto' : parseInt(details) + 'mins');
				},
				QBV: () => {
					// (000
					if (data == '(NAK') return '<b>QBV (SoC compensated voltage?)</b><br />Not recognised'
					const details = data.slice(1);
					return '<b>QBV (SoC compensated voltage?)</b><br />' +
						'Not yet supported';
				},
				Q1: () => {
					// (0000 00000 00 00 00 000 000 000 000 00 00 000 0000 0000 0000 00.00 10
					if (data == '(NAK') return '<b>Q1 (Undocumented)</b><br />Not recognised'
					const statuses = {'10': 'Not charging', '11': 'Bulk mode',
						'12': 'Absorb mode', '13': 'Float mode'},
						fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>Q1 (Undocumented)</b><br />' +
						'Absorb (CV) time: ' + parseInt(fields[0]) + 'sec<br />' +
						'Float time: ' + parseInt(fields[1]) + 'sec<br />' +
						'SCC ok: ' + (fields[2] == '01' ? 'OK<br />' : 'Not OK<br />') +
						'Allow SCC on: ' + (fields[3] == '01' ? 'Yes<br />' : 'No<br />') +
						'Average charge current: ' + parseInt(fields[4]) + 'A<br />' +
						'SCC PWM temperature: ' + parseInt(fields[5]) + '&deg;C<br />' +
						'Battery temperature: ' + parseInt(fields[6]) + '&deg;C<br />' +
						'Transformer temperature: ' + parseInt(fields[7]) + '&deg;C<br />' +
						'GPADAT (GPIO13) bit: ' + fields[8] + '<br />' +
						'Fan lock status: ' + (fields[9] == '01' ? 'Locked<br />' : 'Not Locked<br />') +
						'Fan PWM duty: ' + parseInt(fields[10]) + '<br />' +
						'Fan speed: ' + parseInt(fields[11]) + '%<br />' +
						'SCC charge power: ' + parseInt(fields[12]) + 'W<br />' +
						'Parallel warning: ' + fields[13] + '<br />' +
						'AC sync frequency: ' + parseInt(fields[14]) + 'Hz<br />' +
						'Inverter charge status:' + statuses[fields[15]];
				},
				QGS: () => {
					// (0000
					if (data == '(NAK') return '<b>QGS (Undocumented)</b><br />Not recognised'
					const statuses = {'10': 'Not charging', '11': 'Bulk mode',
						'12': 'Absorb mode'},
						fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QGS (Undocumented)</b><br />' +
						'Not yet implemented';
				},
				QSID: () => {
					// (1492931811100046005535
					if (data == '(NAK') return '<b>QSID (Undocumented: serial no?)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QSID (Undocumented: serial no?)</b><br />' +
						'Not yet implemented';
				},
				QID2: () => {
					// (0000
					if (data == '(NAK') return '<b>QID2 (Undocumented: id?)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QID2 (Undocumented: id?)</b><br />' +
						'Not yet implemented';
				},
				QDM: () => {
					// (0000
					if (data == '(NAK') return '<b>QDM (Undocumented: device model?)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QDM (Undocumented: device model?)</b><br />' +
						'Not yet implemented';
				},
				QCHT: () => {
					// (0000
					if (data == '(NAK') return '<b>QCHT (Undocumented: CHT support?)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QCHT (Undocumented: CHT support?)</b><br />' +
						'Not yet implemented';
				},
				QPPS: () => {
					// (0000
					if (data == '(NAK') return '<b>QPPS (Undocumented: QPPS support?)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QPPS (Undocumented: QPPS support?)</b><br />' +
						'Not yet implemented';
				},
				QCHGS: () => {
					if (data == '(NAK') return '<b>QCHGS (Undocumented: CHGS id?)</b><br />Not recognised'
					// (0000
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QCHGS (Undocumented: CHGS id?)</b><br />' +
						'Not yet implemented';
				},
				QMD: () => {
					// (0000
					if (data == '(NAK') return '<b>QMD (Undocumented)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QMD (Undocumented)</b><br />' +
						'Not yet implemented';
				},
				QVFTR: () => {
					// (0000
					if (data == '(NAK') return '<b>QVFTR (Undocumented)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QVFTR (Undocumented)</b><br />' +
						'Not yet implemented';
				},
				QPIHF: () => {
					// (0000
					if (data == '(NAK') return '<b>QPIHF (Undocumented)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QPIHF (Undocumented)</b><br />' +
						'Not yet implemented';
				},
				QPICF: () => {
					// (0000
					if (data == '(NAK') return '<b>QPICF (Undocumented)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QPICF (Undocumented)</b><br />' +
						'Not yet implemented';
				},
				QFS: () => {
					/*
					 from posting by Coulomb
					 http://forums.aeva.asn.au/viewtopic.php?f=64&t=4332&start=2200#p71161
					*/
					// (00 00 00 0000 0000 0000 000.0 00.00 000.0
					//  00.00 000.0 000.0 00.0 000 000
					if (data == '(NAK') return '<b>QFS Fault query?</b><br />Not recognised'
					const modes = {'00': 'Power On', '01': 'Standby', '02': 'Power Saving', '03': 'Battery',
						'04': 'Line', '05': 'Bypass', '06': 'Fault', '07': 'Shutdown'},
						fields = data.slice(1).split(' '),
						flags = fields[2];
					const status = () => {
						let result = '',
							flags = parseInt(fields[14]);
						if (flags & 4) result += '&nbsp;&nbsp;Load on<br />'
						else result += '&nbsp;&nbsp;Load off<br />';
						if (flags & 8) result += '&nbsp;&nbsp;Inverter relay on<br />'
						else result += '&nbsp;&nbsp;Inverter relay off<br />';
						if (flags & 32) result += '&nbsp;&nbsp;Battery mode<br />';
						if (flags & 64) result += '&nbsp;&nbsp;Line mode<br />';
						if (flags & 128) result += '&nbsp;&nbsp;AC relay on<br />'
						else result += '&nbsp;&nbsp;AC relay off<br />';
						return result;
					}
					return '<b>QFS Fault query?</b><br />' +
						'Fault record status: ' +
							(fields[0] == '01' ? 'Recording' : 'Not recording') +
							'<br/ >' +
						'Fault code: ' + fields[1] + '<br />' +
						'Inverter mode: ' + modes[fields[2]] + '<br />' +
						'Apparent load: ' + fields[3] + 'VA<br />' +
						'True load: ' + fields[4] + 'W<br />' +
						'Inverter load: ' + fields[5] + 'W<br />' +
						'Line voltage: ' + fields[6] + 'V<br />' +
						'Line frequency: ' + fields[7] + 'Hz<br />' +
						'Output voltage: ' + fields[8] + 'V<br />' +
						'Output frequency: ' + fields[9] + 'Hz<br />' +
						'Output current: ' + fields[10] + 'A<br />' +
						'Bus voltage: ' + fields[11] + 'V<br />' +
						'Battery voltage: ' + fields[12] + 'V<br />' +
						'System max temp: ' + fields[13] + '&deg;C<br />' +
						'Status:<br />' + status();
				},
				QFAULT: () => {
					/*
					 from posting by Coulomb
					 http://forums.aeva.asn.au/viewtopic.php?f=64&t=4332&start=2200#p71161
					*/
					// (00 00 0000 0000 0000 000.0 000.0 00.00 000.0 000.0
					if (data == '(NAK') return '<b>QFAULT Fault query?</b><br />Not recognised'
					const modes = {'00': 'Power On', '01': 'Standby', '02': 'Power Saving',
						'03': 'Battery', '04': 'Line', '05': 'Bypass', '06': 'Fault', '07': 'Shutdown'},
						fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QFS Fault query?</b><br />' +
						'Fault code: ' + fields[0] + '<br />' +
						'Inverter mode: ' + modes[fields[1]] + '<br />' +
						'Apparent load: ' + fields[2] + 'VA<br />' +
						'True load: ' + fields[3] + 'W<br />' +
						'Inverter load: ' + fields[4] + 'W<br />' +
						'Bus voltage: ' + fields[5] + 'V<br />' +
						'Line voltage: ' + fields[6] + 'V<br />' +
						'Line frequency: ' + fields[7] + 'Hz<br />' +
						'Output voltage: ' + fields[8] + 'V<br />' +
						'Output current: ' + fields[9] + 'A';
				},
				QSVFW2: () => {
					// (0000
					if (data == '(NAK') return '<b>QSVFW2 (Undocumented)</b><br />Not recognised'
					const fields = data.slice(1).split(' '),
						flags = fields[2];
					return '<b>QSVFW2 (Undocumented)</b><br />' +
						'Not yet implemented';
				}
			}
			// check it is a query command we recognise
			if (queries.hasOwnProperty(cmd))
				document.querySelector('#parsed').innerHTML = queries[cmd]();
		}

		const getBuff = str => {
			return Buffer.concat([
				Buffer.from(str),
				CRCXModem(str),
				Uint8Array.from([0x0D])
			])
		}
		// simulate port.write() and parser.on('data') events for testing
		fakePort = {
			write: (buff, err) => {
				// (mostly) real data returned from Conversol 5K III (except s/n)
				switch (cmd) {
					case 'QPI': rxData(getBuff('(PI30')); break;
					case 'QID':  rxData(getBuff('(92931811100000')); break;
					case 'QVFW':  rxData(getBuff('(VERFW:00020.65')); break;
					case 'QVFW2': rxData(getBuff('(NAK')); break;
					case 'QVFW3': rxData(getBuff('(VERFW:00001.21')); break;
					case 'QVFW4': rxData(getBuff('(NAK')); break;
					case 'QPIRI': rxData(getBuff('(230.0 21.7 230.0 50.0 21.7 5000 5000 48.0 49.0 43.0 58.4 54.0 1 20 040 0 2 1 1 01 0 0 54.0 0')); break;
					case 'QFLAG': rxData(getBuff('(EaxyzDbjkuv')); break;
					case 'QPIGS': rxData(getBuff('(000.0 00.0 229.8 50.0 0137 0022 002 428 54.00 000 100 0035 00.0 305.6 00.00 00001 00010000 00 00 00000 010')); break;
					case 'QPIGS2': rxData(getBuff('(NAK')); break;
					case 'QMOD': rxData(getBuff('(B')); break;
					case 'QPIWS': rxData(getBuff('(000001000000000000000000000000000000')); break;
					case 'QDI': rxData(getBuff('(230.0 50.0 0030 42.0 54.0 56.4 46.0 60 0 0 2 0 0 0 0 0 1 1 1 0 1 0 54.0 0 1')); break;
					case 'QBEQI': rxData(getBuff('(0 060 030 040 030 58.40 000 120 0 0000')); break;
					case 'QMCHGCR': rxData(getBuff('(010 020 030 040 050 060 070 080')); break;
					case 'QMUCHGCR': rxData(getBuff('(002 010 020 030 040 050 060')); break;
					case 'QMSCHGCR': rxData(getBuff('(NAK')); break;
					case 'QBOOT': rxData(getBuff('(NAK')); break;
					case 'QOPM': rxData(getBuff('(NAK')); break;
					case 'QCST': rxData(getBuff('(NAK')); break;
					case 'QCVT': rxData(getBuff('(NAK')); break;
					case 'QBV': rxData(getBuff('(NAK')); break;
					case 'Q1': rxData(getBuff('(01 00 00 000 035 027 031 00 00 000 0030 0000 13')); break;
					case 'QGS': rxData(getBuff('(NAK')); break;
					case 'QSID': rxData(getBuff('(1492931811100046005535')); break;
					case 'QID2': rxData(getBuff('(NAK')); break;
					case 'QDM': rxData(getBuff('(NAK')); break;
					case 'QGM': rxData(getBuff('(NAK')); break;
					case 'QCHT': rxData(getBuff('(NAK')); break;
					case 'QPPS': rxData(getBuff('(NAK')); break;
					case 'QCHGS': rxData(getBuff('(NAK')); break;
					case 'QMD': rxData(getBuff('(NAK')); break;
					case 'QVFTR': rxData(getBuff('(NAK')); break;
					case 'QPIHF': rxData(getBuff('(NAK')); break;
					case 'QPICF': rxData(getBuff('(NAK')); break;
					case 'QFS': rxData(getBuff('(NAK')); break;
					case 'QFAULT': rxData(getBuff('(NAK')); break;
					case 'QSVFW2': rxData(getBuff('(NAK')); break;
					default: parseQuery(cmd, '');
				}
			}
		}

		// recieve data responses either from inverter or fakePort
		const rxData = data => {
			// response = body + crc + /r
			const crc = data.slice(-3, -1),
				body = data.slice(0, -3).toString(),
				crcTxt = crc.toString('hex'),
				chk = CRCXModem(body);
			// check crc
			comsError.textContent = (chk[0] & crc[0] && chk[1] & crc[1]) ? '' : 'CRC error!';
			// update window and log with results
		 	document.querySelector('#recv').textContent = body;
			console.log('Rx:', body, `(${crcTxt})`);
		 	parseQuery(cmd, body);
		}

		// calculate XModem CRC-16
		const CRCXModem = str => {
			let crc = 0;
			for (let c = 0; c < str.length; c++) {
				crc ^= str.charCodeAt(c) << 8;
				for (let i = 0; i < 8; i++) {
					if (crc & 0x8000)
						crc = (crc << 1) ^ 0x1021;
					else
						crc = crc << 1;
				}
			}
			// increment crc bytes containing lf, cr and '('
			crc = crc  & 0xffff;
			let msb = crc >>> 8,
				lsb = crc & 0xff;
			if ([0x0a,0x0d,0x28].includes(msb)) {
				msb++;
			}
			if ([0x0a,0x0d,0x28].includes(lsb)) {
				lsb++;
			}
			return Uint8Array.from([msb, lsb]);
		}

		// send command to controller
		const sendQuery = txt => {
			// convert command, crc and \r to buffer
			const bytes = Buffer.concat([
				Buffer.from(txt, 'utf-8'),
				CRCXModem(txt),
				Uint8Array.from([0x0D])
			]);
			// save the command so the reply parser knows what it is
			cmd = txt;
			// update window and log
			document.querySelector('#sent').textContent = txt;
			console.log('Tx:', bytes.toString('hex'), `(${txt})`);
			// send it
			port.write(bytes, err => {
				if (err) {
					console.error('Writing returned:', err.message);
				}
			});
		}

		///////////////////////////////// main /////////////////////

		// set up serial connection
		sp.list((err, ports) => {
			// window elements to update
			const comsInfo = document.querySelector('#port'),
				comsError = document.querySelector('#comsError');
			// handle listing errors
			if (err) {
				console.error('Listing ports returned:', err.message);
				return;
			}
			// find port with Prolific Technology adapter
			const devices = ports.filter( elm => {
				// Cypress 0665:5161
				return elm.vendorId == '067b'  && elm.productId == '2303';	
			});
			// use the first valid port if there is one
			if (devices.length) {
				port = new sp(devices[0].comName, {
					baudRate: 2400
				});
				// set up parser to read whole lines
				port.pipe(parser);
				// handle open port errors
				port.on('error', err => {
				  console.error('Opening port returned:', err.message);
				});
				// handle coms responses
				port.on('open', () => {
					console.log('Opened', port.path, port);
					console.log('device:', devices[0]);
					parser.on('data', data => {rxData(data)});
				});
				// update window and log
				comsInfo.innerHTML =
					'<b>Found</b> ' + devices[0].manufacturer + ' <b>on</b> '
						+ devices[0].comName;
				console.log('Found', devices[0].manufacturer.trim(),
					'on', devices[0].comName);
			} else {
				console.warn('No serial device found!');
				comsInfo.innerHTML =
					'<b class="fault">Not connected:</b> test responses only.';
				// we can still test the software with no connection by calling
				// our fakePort's write instead of port.write()
				test = true;
				port = fakePort;
			}
		});

/*		// try bluetooth
		var btSerial = new (require('bluetooth-serial-port')).BluetoothSerialPort();

		btSerial.on('found', function(address, name) {
			btSerial.findSerialPortChannel(address, function(channel) {
				btSerial.connect(address, channel, function() {
					console.log('Bluetooth connected');

					btSerial.write(Buffer.from('my data', 'utf-8'), function(err, bytesWritten) {
						if (err) console.log(err);
					});

					btSerial.on('data', function(buffer) {
						console.log(buffer.toString('utf-8'));
					});
				}, function () {
					console.log('Bluetooth cannot connect');
				});

				// close the connection when you're ready
				btSerial.close();
			}, function() {
				console.log('Bluetooth found nothing');
			});
		});

		btSerial.inquire();

*/
	</script>
    <style>
        body { background-color: Window; color: WindowText; font: caption; }
		button { display: table-cell; margin-bottom: .25em; }
        #control { float: left; margin: -1.25em 2em 0 0; width: 45%; }
		#buttons { display: table; margin-top: 0; }
		#buttons div { float: left; }
		#comsError, .fault, .noFault, .warning { background-color: #999999; }
		#comsError, .fault { color: red; }
		.noFault { color: green; }
		.warning { color: yellow;  }
	</style>
</head>

<body>
    <div id="control">
        <p><span id="port"></span> <span id="comsError"></span><br /></p>
        <p>Command <input type="text" onchange="sendQuery(this.value)" /></p>
        <p>SENT <span id="sent"></span></p>
        <p>REPLY <span id="recv"></span></p>
        <p><span id="parsed"></span></p>
    </div>
    <div id="buttons">
    	<div>
			<button onClick="sendQuery('QPI')">Protocol ID</button><br />
			<button onClick="sendQuery('QID')">Serial number</button><br />
			<button onClick="sendQuery('QVFW')">Main CPU Firmware version</button><br />
			<button onClick="sendQuery('QVFW2')">SCC1 CPU Firmware version?</button><br />
			<button onClick="sendQuery('QVFW3')">SCC2 CPU Firmware version</button><br />
			<button onClick="sendQuery('QVFW4')">SCC3 CPU Firmware version?</button><br />
			<button onClick="sendQuery('QPIRI')">Rating Information</button><br />
			<button onClick="sendQuery('QFLAG')">Flag status</button><br />
			<button onClick="sendQuery('QPIGS')">General status</button><br />
			<button onClick="sendQuery('QPIGS2')">General status 2?</button><br />
			<button onClick="sendQuery('QMOD')">Operating Mode</button><br />
			<button onClick="sendQuery('QPIWS')">Warning Status</button><br />
			<button onClick="sendQuery('QDI')">Default setting values</button><br />
			<button onClick="sendQuery('QMCHGCR')">Max charging current settings</button><br />
			<button onClick="sendQuery('QMUCHGCR')">Max utility charge current settings</button><br />
			<button onClick="sendQuery('QMSCHGCR')">Max solar charge current settings?</button><br />
			<button onClick="sendQuery('QBOOT')">DSP has bootstrap?</button><br />
			<button onClick="sendQuery('QOPM')">Output mode (For 4000/5000)?</button><br />
			<button onClick="sendQuery('QCST')">Charging stages?</button><br />
			<button onClick="sendQuery('QCVT')">Absorb Charging time?</button><br />
			<button onClick="sendQuery('QBEQI')">Equalisation</button>
		</div>
		<div>
			<button onClick="sendQuery('QBV')">QBV: SoC?</button><br />
			<button onClick="sendQuery('Q1')">Q1: status</button><br />
			<button onClick="sendQuery('QGS')">QGS: ?</button><br />
			<button onClick="sendQuery('QSID')">QSID: SCC id?</button><br />
			<button onClick="sendQuery('QID2')">QID2: id?</button><br />
			<button onClick="sendQuery('QDM')">QDM: device model?</button><br />
			<button onClick="sendQuery('QCHT')">QCHT: CHT support?</button><br />
			<button onClick="sendQuery('QPPS')">QPPS: QPPS support?</button><br />
			<button onClick="sendQuery('QCHGS')">QCHGS: QCHGS id?</button><br />
			<button onClick="sendQuery('QMD')">QMD: ?</button><br />
			<button onClick="sendQuery('QVFTR')">QVFTR: ?</button><br />
			<button onClick="sendQuery('QPIHF')">QPIHF: ?</button><br />
			<button onClick="sendQuery('QPICF')">QPICF: ?</button><br />
			<button onClick="sendQuery('QSVFW2')">QSVFW2: ?</button><br />
			<button onClick="sendQuery('QFS')">QFS: Fault query 1?</button><br />
			<button onClick="sendQuery('QFAULT')">QFS: Fault query2?</button><br />
			<!--button onClick="sendQuery('Q3GV')">Q3GV:</button><br /-->
			<!--button onClick="sendQuery('Q3GC')">Q3GC:</button><br /-->
			<!--button onClick="sendQuery('Q3GW')">Q3GW:</button><br /-->
			<!--button onClick="sendQuery('Q3AV')">Q3AV:</button><br /-->
			<!--button onClick="sendQuery('Q3AC')">Q3AC:</button><br /-->
			<!--button onClick="sendQuery('Q3AL')">Q3AL:</button><br /-->
			<!--button onClick="sendQuery('Q3AW')">Q3AW:</button><br /-->
			<!--button onClick="sendQuery('QPIFS')">QPIFS:</button><br /-->
			<!--button onClick="sendQuery('QSPIFS')">QSPIFS:</button><br /-->
			<!--button onClick="sendQuery('QTPIFS')">QTPIFS:</button><br /-->
			<!--button onClick="sendQuery('QT')">QT:</button><br /-->
			<!--button onClick="sendQuery('QFET')">QFET:</button><br /-->
			<!--button onClick="sendQuery('QEY')">QEY:</button><br /-->
			<!--button onClick="sendQuery('QEM')">QEM:</button><br /-->
			<!--button onClick="sendQuery('QED')">QED:</button><br /-->
			<!--button onClick="sendQuery('QEH')">QEH:</button><br /-->
			<!--button onClick="sendQuery('QBYV')">QBYV:</button><br /-->
			<!--button onClick="sendQuery('QBYF')">QBYF:</button><br /-->
			<!--button onClick="sendQuery('QGOV')">QGOV:</button><br /-->
			<!--button onClick="sendQuery('QGOF')">QGOF:</button><br /-->
			<!--button onClick="sendQuery('QOPMP')">QOPMP:</button><br /-->
			<!--button onClick="sendQuery('QMPPTV')">QMPPTV:</button><br /-->
			<!--button onClick="sendQuery('QPVIPV')">QPVIPV:</button><br /-->
			<!--button onClick="sendQuery('QLST')">QLST:</button><br /-->
			<!--button onClick="sendQuery('QTPR')">QTPR:</button><br /-->
			<!--button onClick="sendQuery('QODI2')">QODI2:</button><br /-->
			<!--button onClick="sendQuery('QSTS')">QSTS:</button><br /-->
			<!--button onClick="sendQuery('QGLTV')">QGLTV:</button><br /-->
			<!--button onClick="sendQuery('QADI')">QADI:</button><br /-->
			<!--button onClick="sendQuery('QVB')">QVB:</button><br /-->
			<!--button onClick="sendQuery('QCHGC')">QCHGC:</button><br /-->
			<!--button onClick="sendQuery('QMCC')">QMCC:</button><br /-->
			<!--button onClick="sendQuery('QII')">QII:</button><br /-->
			<!--button onClick="sendQuery('QPIBI')">QPIBI:</button><br /-->
			<!--button onClick="sendQuery('QPINBY')">QPINBY:</button><br /-->
			<!--button onClick="sendQuery('QFT')">QFT:</button><br /-->
			<!--button onClick="sendQuery('QMN')">QMN:</button><br /-->
			<!--button onClick="sendQuery('QGMN')">QGMN:</button><br /-->
			<!--button onClick="sendQuery('QEBGP')">QEBGP:</button><br /-->
			<!--button onClick="sendQuery('QOPF')">QOPF:</button><br /-->
			<!--button onClick="sendQuery('QPDG')">QPDG:</button><br /-->
			<!--button onClick="sendQuery('QPPD')">QPPD:</button><br /-->
			<!--button onClick="sendQuery('QPFL')">QPFL:</button><br /-->
			<!--button onClick="sendQuery('QP2GS')">QP2GS:</button><br /-->
			<!--button onClick="sendQuery('QPGS0')">QPGS0:</button><br /-->
			<!--button onClick="sendQuery('QP2GS0')">QP2GS0:</button><br /-->
			<!--button onClick="sendQuery('QRST')">QRST:</button><br /-->
		</div>
    </div>
</body>

</html>